import OpenAI from "openai";

const express = require("express");
const axios = require("axios");

const app = express();
const port = 3001;

// Google Search API configuration
const googleApiKey = process.env.GOOGLE_SEARCH_API_KEY;
const mapsApiKey = process.env.GOOGLE_API_KEY;
const googleSearchEngineId = "e0b3c25aac1c6497d";

// TODO: verify the type of data that is generated by chat-gpt
const spec =
  "list of 'cities' with 'name' 'state' 'country', list of 'landmarks' (string), list of 'events' with 'name' and 'date' and 'time'";
const systemPrompt =
  "Extract city names, location data, country names, any geographical location, landmarks, etc. from the following text:, and format it in json, accorinding to the following specification: " +
  spec;
const mapsPrompt = "show near me";
const prompt_to_split_query_type =
  "Act as a location assistant. Determine if 1. the user wants directions to a specific place, or 2. suggestions for activities or locations. Type only 1 or 2 as your answer.";
const prompt_to_get_address =
  "Extract the address or location from the query string. Only the address.";
const route_categories = ["safety", "health", "scenery"];

// HELPER FUNCTIONS

// Get places suggestions from Google Places Autocomplete API
async function getPlaceSuggestions(input) {
  try {
    const response = await fetch(
      `https://maps.googleapis.com/maps/api/place/autocomplete/json?input=${encodeURIComponent(input)}&key=${mapsApiKey}`
    );
    if (!response.ok) {
      throw new Error(`Places Autocomplete API request failed with status ${response.status}`);
    }
    const data = await response.json();
    console.log("Places Autocomplete API response data:", data);

    if (data.predictions.length === 0) {
      console.warn("No suggestions found for the given input:", input);
      return [];
    }

    return data.predictions.map(prediction => ({
      description: prediction.description,
      place_id: prediction.place_id
    }));
  } catch (error) {
    console.error("Error in getPlaceSuggestions:", error);
    return [];
  }
}

// Extract the address from the user's query
const getAddress = async (str) => {
  const openai = new OpenAI({
    apiKey: process.env.OPENAI_KEY,
    dangerouslyAllowBrowser: true,
  });

  const messages = [
    { role: "system", content: prompt_to_get_address },
    { role: "user", content: str },
  ];

  const completion = await openai.chat.completions.create({
    messages: messages,
    model: "gpt-4o-mini",
  });
  // console.log("CHAT GPT REPONSE: "+completion.choices[0].message.content);
  return completion.choices[0].message.content;
};

// Determine whether the user wants directions or suggestions
const determineIntent = async (query) => {
  const openai = new OpenAI({
    apiKey: process.env.OPENAI_KEY,
    dangerouslyAllowBrowser: true,
  });

  const messages = [
    { role: "system", content: prompt_to_split_query_type },
    { role: "user", content: query },
  ];

  const completion = await openai.chat.completions.create({
    messages: messages,
    model: "gpt-4o-mini",
  });
  // console.log("CHAT GPT REPONSE: "+completion.choices[0].message.content);
  return completion.choices[0].message.content;
};

// Function to get latitude and longitude using Google Maps Geocoding API
async function getLatLng(address) {
  const suggestions = getPlaceSuggestions(address);

  if (suggestions.length === 0) {
    console.warn("No suggestions found for the given address:", address);
    return [];
  }
  
  // first 5 results
  for(let i = 0; i < min(suggestions.length, 5); i++) {

  }

  const response = await fetch(
    `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(
      "vancouver"
    )}&key=${mapsApiKey}`
  );
  if (!response.ok) {
    throw new Error(
      `Geocoding API request failed with status ${response.status}`
    );
  }
  const data = await response.json();
  console.log("DATA: ",data);
  if (data.results.length === 0) {
    // throw new Error("No results found for the given address");
    console.log("No results found for the given address");
  }
  return data.results;
}
// typeof data.results
// results[]: {
//   types[]: string,
//   formatted_address: string,
//   address_components[]: {
//     short_name: string,
//     long_name: string,
//     postcode_localities[]: string,
//     types[]: string
//   },
//   partial_match: boolean,
//   place_id: string,
//   postcode_localities[]: string,
//   geometry: {
//     location: LatLng,
//     location_type: GeocoderLocationType
//     viewport: LatLngBounds,
//     bounds: LatLngBounds
//   }
//  }

// Pass in http://localhost:3001/search?q=your_search_query
app.get("/search", async (req, res) => {
  const query = req.query.q;
  const lat = req.query.lat;
  const lng = req.query.lng;

  if (!query) {
    return res.status(400).send('Query parameter "q" is required');
  }

  // Directions
  const intent = await determineIntent(query);
  if (intent === "1") {
    const results = await getLatLng(getAddress(query));
    console.log("NAVIGATION: " + results[0].geometry.location);
  } else {
    try {
      console.log("LIST PLACES: " + query);

      // Search Google
      const googleResponse = await fetch(
        `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${googleSearchEngineId}&q=${query}`
      );
      if (!googleResponse.ok) {
        throw new Error(
          `Google API request failed with status ${googleResponse.status}`
        );
      }
      const googleData = await googleResponse.json();
      console.log(googleData);
      // console.log(googleResponse);

      // // Extract search results
      const searchResults = googleData.items
        .map((item) => item.snippet)
        .join("\n");
      console.log("SEARCH RESULTS: " + searchResults);

      // Seaerch results
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_KEY,
        dangerouslyAllowBrowser: true,
      });

      // Parse search results for city names, etc.

      // Find city names, etc.
      const messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: searchResults },
      ];

      const completion = await openai.chat.completions.create({
        messages: messages,
        model: "gpt-4o-mini",
      });

      console.log("CHAT GPT REPONSE: " + completion.choices[0].message.content);
    } catch (error) {
      console.error(error);
      res.status(500).send("An error occurred");
    }
  }
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
